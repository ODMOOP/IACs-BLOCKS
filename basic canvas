<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>IAC Blocks â€“ Curve Directly From Balls</title>
<style>
  body { margin:0; background:#2b2b2b; overflow:hidden; }
  #panel { position:fixed; top:0; left:0; width:80px; height:100vh; background:#1d1d1d; }
  #canvas { position:absolute; top:0; left:80px; width:calc(100vw - 80px); height:100vh; background:#303030; }
  .option-menu { position:absolute; background:#444; color:#fff; padding:2px; border-radius:3px; font-size:12px; z-index:2000; user-select:none; }
  .option-menu div { padding:3px 6px; cursor:pointer; }
  .option-menu div:hover { background:#666; }
  svg.curve-layer { position:absolute; top:0; left:80px; width:calc(100vw - 80px); height:100vh; pointer-events:none; overflow:visible; }
  svg path { stroke:orange; stroke-width:1; fill:none; pointer-events:visibleStroke; }
  .curve-highlight { stroke-width:2 !important; }
</style>
</head>
<body>
<div id="panel"></div>
<div id="canvas"></div>
<svg class="curve-layer"></svg>

<script src="https://unpkg.com/konva/konva.min.js"></script>
<script>
const stage = new Konva.Stage({ container:'canvas', width:window.innerWidth-80, height:window.innerHeight, draggable:true });
const layer = new Konva.Layer(); stage.add(layer);
const curveLayer=document.querySelector('.curve-layer');
let copyData=null,curves=[];

class IACBlock{
  constructor(x,y,num=1,word='BLOCK'){
    this.group=new Konva.Group({x,y,draggable:true});
    const capsule=new Konva.Rect({width:100,height:30,fill:'#D7BB91',cornerRadius:15});
    const numBox=new Konva.Rect({width:30,height:30,fill:'#111',cornerRadius:15});
    const numText=new Konva.Text({text:num.toString(),fontSize:14,fill:'white',width:30,height:30,align:'center',verticalAlign:'middle'});
    const wordText=new Konva.Text({text:word,x:35,width:65,height:30,fontSize:14,fill:'black',align:'center',verticalAlign:'middle'});
    const whitePort=this._makePort(50,0,'white','port-dest',Math.PI,0);
    const orangePort=this._makePort(30,30,'orange','port-src',0,Math.PI);
    const yellowPort=this._makePort(70,30,'yellow','port-src',0,Math.PI);
    this.group.add(capsule,numBox,numText,wordText,whitePort,orangePort,yellowPort);
    [orangePort,yellowPort].forEach(port=>{
      port.on('mousedown',(e)=>{ e.cancelBubble=true; startCurveDrag(port); });
    });
    this.group.on('contextmenu',(e)=>{e.evt.preventDefault();showBlockMenu(this.group,e.evt.clientX,e.evt.clientY);});
    this.group.on('dragmove',()=>{redrawCurves();});
    layer.add(this.group);
  }
  _makePort(x,y,color,name,start,end){
    return new Konva.Shape({
      sceneFunc:function(ctx,shape){
        ctx.beginPath();
        ctx.arc(x,y,8,start,end,false);
        ctx.closePath();
        ctx.fillStrokeShape(shape);
      },
      fill:color,
      name:name
    });
  }
}

// helpers
function stageToScreen(pos){
  const scale=stage.scaleX()||1;
  return {x:stage.x()+pos.x*scale+80, y:stage.y()+pos.y*scale};
}
function screenToStage(x,y){
  const scale=stage.scaleX()||1;
  return {x:(x-80-stage.x())/scale, y:(y-stage.y())/scale};
}

// curve logic
function drawCurve(path,x1,y1,x2,y2){
  const cp1X=x1, cp1Y=(y1+y2)/2;
  const cp2X=x2, cp2Y=(y1+y2)/2;
  path.setAttribute('d',`M ${x1},${y1} C ${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x2},${y2}`);
}
function redrawCurves(){
  curves.forEach(c=>{
    const sAbs=c.start.getAbsolutePosition(), eAbs=c.end.getAbsolutePosition();
    const sp=stageToScreen(sAbs), ep=stageToScreen(eAbs);
    drawCurve(c.path,sp.x,sp.y,ep.x,ep.y);
  });
}
function deleteCurve(c){ c.path.remove(); curves=curves.filter(cc=>cc!==c); }
function attachCurveEvents(c){
  const path=c.path;
  path.addEventListener('mouseenter',()=>path.classList.add('curve-highlight'));
  path.addEventListener('mouseleave',()=>path.classList.remove('curve-highlight'));
  path.addEventListener('contextmenu',e=>{e.preventDefault();deleteCurve(c);});
}
function startCurveDrag(port){
  const sAbs=port.getAbsolutePosition();
  const sp=stageToScreen(sAbs);
  const path=document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('stroke',port.fill()); curveLayer.appendChild(path);
  drawCurve(path,sp.x,sp.y,sp.x,sp.y);
  function move(e){ drawCurve(path,sp.x,sp.y,e.clientX,e.clientY); }
  function end(e){
    document.removeEventListener('mousemove',move);
    document.removeEventListener('mouseup',end);
    const stagePos=screenToStage(e.clientX,e.clientY);
    const target=stage.getIntersection(stagePos);
    if(target && target.hasName('port-dest')){
      const eAbs=target.getAbsolutePosition();
      const ep=stageToScreen(eAbs);
      drawCurve(path,sp.x,sp.y,ep.x,ep.y);
      const curveObj={path,start:port,end:target};
      curves.push(curveObj); attachCurveEvents(curveObj);
    } else path.remove();
  }
  document.addEventListener('mousemove',move);
  document.addEventListener('mouseup',end);
}

// menus + zoom
function showBlockMenu(block,x,y){
  closeMenus();
  const menu=document.createElement('div'); menu.className='option-menu'; menu.style.left=x+'px'; menu.style.top=y+'px';
  menu.innerHTML=`<div id="edit">Edit</div><div id="copy">Copy</div><div id="delete">Delete</div><div id="detach">Detach</div>`;
  document.body.appendChild(menu);
  menu.querySelector('#edit').onclick=()=>{const t=block.findOne(n=>n instanceof Konva.Text&&n.x()>0);const nw=prompt('Edit word:',t.text());if(nw!==null)t.text(nw);closeMenus();layer.draw();};
  menu.querySelector('#copy').onclick=()=>{const t=block.findOne(n=>n instanceof Konva.Text&&n.x()>0);copyData={word:t.text()};closeMenus();};
  menu.querySelector('#delete').onclick=()=>{curves=curves.filter(c=>{if(c.start.getParent()===block||c.end.getParent()===block){c.path.remove();return false;}return true;});block.destroy();closeMenus();layer.draw();};
  menu.querySelector('#detach').onclick=()=>{curves=curves.filter(c=>{if(c.start.getParent()===block||c.end.getParent()===block){c.path.remove();return false;}return true;});closeMenus();layer.draw();};
  document.addEventListener('click',closeMenus,{once:true});
}
stage.getContainer().addEventListener('contextmenu',e=>{e.preventDefault();const pos=stage.getPointerPosition();const target=stage.getIntersection(pos);if(!target)showCanvasMenu(e.clientX,e.clientY);});
function showCanvasMenu(x,y){
  closeMenus();
  const menu=document.createElement('div'); menu.className='option-menu'; menu.style.left=x+'px'; menu.style.top=y+'px';
  menu.innerHTML=`<div id="paste">Paste</div><div id="cancel">Cancel</div>`; document.body.appendChild(menu);
  menu.querySelector('#paste').onclick=()=>{if(copyData){const pos=stage.getPointerPosition();new IACBlock(pos.x,pos.y,99,copyData.word);}closeMenus();};
  menu.querySelector('#cancel').onclick=closeMenus; document.addEventListener('click',closeMenus,{once:true});
}
function closeMenus(){document.querySelectorAll('.option-menu').forEach(m=>m.remove());}
stage.on('wheel',(e)=>{e.evt.preventDefault();const scaleBy=1.05;const old=stage.scaleX()||1;const p=stage.getPointerPosition();const mouse={x:(p.x-stage.x())/old,y:(p.y-stage.y())/old};const dir=e.evt.deltaY>0?-1:1;const ns=dir>0?old*scaleBy:old/scaleBy;stage.scale({x:ns,y:ns});stage.position({x:p.x-mouse.x*ns,y:p.y-mouse.y*ns});stage.batchDraw();redrawCurves();});

new IACBlock(150,100,1,'BLOCK'); layer.draw();
</script>
</body>
</html>
