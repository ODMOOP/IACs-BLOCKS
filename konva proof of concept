<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bezier Curve Anchored Ends with Gradient Stroke</title>
<style>
  body { margin:0; background:#2b2b2b; overflow:hidden; }
  #canvas { width:100vw; height:100vh; background:#303030; }
</style>
</head>
<body>
<div id="canvas"></div>
<script src="https://unpkg.com/konva/konva.min.js"></script>
<script>
const stage = new Konva.Stage({
  container: 'canvas',
  width: window.innerWidth,
  height: window.innerHeight,
  draggable: false
});
const layer = new Konva.Layer();
stage.add(layer);

const curveGroup = new Konva.Group({
  x: stage.width() / 2,
  y: stage.height() / 2
});
layer.add(curveGroup);

// Endpoints
const startCircle = new Konva.Circle({
  x: -150, y: 0, radius: 8,
  fill: 'orange', stroke: 'black', strokeWidth: 1,
  draggable: true
});
const endCircle = new Konva.Circle({
  x: 150, y: 0, radius: 8,
  fill: 'white', stroke: 'black', strokeWidth: 1,
  draggable: true
});

// Curve (drawn first so it's behind circles)
const curve = new Konva.Line({
  points: [],
  strokeWidth: 3,
  bezier: true
});
curveGroup.add(curve);
curveGroup.add(startCircle);
curveGroup.add(endCircle);

// Update function with anchored control points + gradient stroke
function updateCurve() {
  const sx = startCircle.x();
  const sy = startCircle.y();
  const ex = endCircle.x();
  const ey = endCircle.y();

  const offset = 80;

  const cp1x = sx + offset;
  const cp1y = sy;

  const cp2x = ex - offset;
  const cp2y = ey;

  // update curve points
  curve.points([sx, sy, cp1x, cp1y, cp2x, cp2y, ex, ey]);

  // update gradient stroke from start (orange) to end (white)
  curve.strokeLinearGradientStartPoint({ x: sx, y: sy });
  curve.strokeLinearGradientEndPoint({ x: ex, y: ey });
  curve.strokeLinearGradientColorStops([0, 'orange', 1, 'white']);

  layer.batchDraw();
}

startCircle.on('dragmove', updateCurve);
endCircle.on('dragmove', updateCurve);

// Initial draw
updateCurve();
layer.draw();

// Zoom
stage.on('wheel', (e) => {
  e.evt.preventDefault();
  const scaleBy = 1.05;
  const oldScale = stage.scaleX();
  const pointer = stage.getPointerPosition();
  const mousePointTo = {
    x: (pointer.x - stage.x()) / oldScale,
    y: (pointer.y - stage.y()) / oldScale
  };
  const dir = e.evt.deltaY > 0 ? -1 : 1;
  const newScale = dir > 0 ? oldScale * scaleBy : oldScale / scaleBy;
  stage.scale({ x: newScale, y: newScale });
  stage.position({
    x: pointer.x - mousePointTo.x * newScale,
    y: pointer.y - mousePointTo.y * newScale
  });
  stage.batchDraw();
});

// Pan with middle mouse drag
stage.on('mousedown', (e) => {
  if (e.evt.button === 1) stage.draggable(true);
});
stage.on('mouseup', (e) => {
  if (e.evt.button === 1) stage.draggable(false);
});
stage.getContainer().addEventListener('contextmenu', (e) => e.preventDefault());
</script>
</body>
</html>
